from __future__ import annotations

from dataclasses import dataclass
import logging
from decimal import Decimal
from enum import Enum
from typing import Any, Optional
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed

import json
import litellm

from domain.statement_d import TransactionD


class TransactionCategory(Enum):
    """Categories for business transaction classification"""
    
    # Business Operations
    RENT = "rent"
    UTILITIES = "utilities"
    PAYROLL_SALARIES = "payroll_salaries"
    OFFICE_SUPPLIES = "office_supplies"
    PROFESSIONAL_SERVICES = "professional_services"
    MARKETING_ADVERTISING = "marketing_advertising"
    TRAVEL_MEALS = "travel_meals"
    INSURANCE = "insurance"
    
    # Debt/Financing
    LOAN_PAYMENT = "loan_payment"
    CREDIT_CARD_PAYMENT = "credit_card_payment"
    BANK_FEES = "bank_fees"
    
    # Revenue/Income
    CUSTOMER_PAYMENT = "customer_payment"
    DEPOSIT = "deposit"
    TRANSFER_IN = "transfer_in"
    
    # Expenses
    VENDOR_PAYMENT = "vendor_payment"
    WITHDRAWAL = "withdrawal"
    TRANSFER_OUT = "transfer_out"
    
    # Uncategorized
    OTHER = "other"
    ERROR = "error"
    
    def __str__(self) -> str:
        return self.value
    
    @classmethod
    def list_all(cls) -> list[str]:
        """Return all category values as strings (excluding ERROR)"""
        return [cat.value for cat in cls if cat != cls.ERROR]


@dataclass
class CategorizedTransaction:
    """Transaction with assigned category"""
    
    transaction: TransactionD
    category: TransactionCategory
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "transaction": self.transaction.to_dict(),
            "category": self.category.value,
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> CategorizedTransaction:
        return cls(
            transaction=TransactionD.from_dict(data["transaction"]),
            category=TransactionCategory(data["category"]),
        )


@dataclass
class CategorySummary:
    """Summary statistics for a transaction category"""
    
    category: TransactionCategory
    total_amount: Decimal
    transaction_count: int
    average_amount: Decimal
    percentage_of_total: float
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "category": self.category.value,
            "total_amount": str(self.total_amount),
            "transaction_count": self.transaction_count,
            "average_amount": str(self.average_amount),
            "percentage_of_total": round(self.percentage_of_total, 2),
        }


class TransactionCategorizationService:
    
    DEFAULT_MODEL = "gpt-5"
    DEFAULT_WORKERS = 10
    DEFAULT_TEMPERATURE = 0.1
    MAX_RETRIES = 2
    
    def __init__(
        self,
        model: str = DEFAULT_MODEL,
        workers: int = DEFAULT_WORKERS,
        temperature: float = DEFAULT_TEMPERATURE,
        max_retries: int = MAX_RETRIES
    ):
        self.model = model
        self.workers = workers
        self.temperature = temperature
        self.max_retries = max_retries
        self._prompt_template = self._create_prompt_template()
        self.logger = logging.getLogger(__name__)
    
    def _create_prompt_template(self) -> str:
        """Create the categorization prompt template"""
        categories = ', '.join(TransactionCategory.list_all())
        return (
            "You are a financial assistant that categorizes business transactions. "
            "Given transaction details, assign the most appropriate category from: "
            f"{categories}\n\n"
            "Transaction:\n"
            "- Description: {description}\n"
            "- Amount: ${amount}\n"
            "- Type: {transaction_type}\n"
            "- Date: {date}\n\n"
            "Reply with ONLY the category name. If unsure, use 'other'."
        )
    
    def _build_prompt(self, transaction: TransactionD) -> str:
        return self._prompt_template.format(
            description=transaction.transaction_description or "No description",
            amount=abs(transaction.transaction_amount),
            transaction_type=transaction.transaction_type.value if transaction.transaction_type else "unknown",
            date=transaction.transaction_date
        )
    
    def _parse_category_response(self, response_text: str) -> TransactionCategory:
        category_str = response_text.strip().lower()
        try:
            return TransactionCategory(category_str)
        except ValueError:
            self.logger.warning(f"Unknown category '{category_str}', defaulting to ERROR")
            return TransactionCategory.ERROR
    
    def _categorize_single_transaction(
        self,
        transaction: TransactionD,
    ) -> CategorizedTransaction:

        response = litellm.completion(
            model=self.model,
            messages=[{"role": "user", "content": self._build_prompt(transaction)}],
            temperature=self.temperature,
        )

        
        category = self._parse_category_response(
            response.choices[0]. message.content
        )
        
        return CategorizedTransaction(transaction=transaction, category=category)
      

    def categorize_transactions(
        self,
        transactions: list[TransactionD],
    ) -> list[CategorizedTransaction]:
        
        if not transactions:
            return []
        
        total = len(transactions)
        results: list[Optional[CategorizedTransaction]] = [None] * total
        completed = 0
        
        def process_transaction(index: int, transaction: TransactionD) -> tuple[int, CategorizedTransaction]:
            nonlocal completed
            result = self._categorize_single_transaction(transaction)
            
            completed += 1
            # Log progress
            desc = transaction.transaction_description[:40] if transaction.transaction_description else "No desc"
            self.logger.info(f"Progress: {completed}/{total} - {desc}... â†’ {result.category.value}")
            
            return index, result
        
        with ThreadPoolExecutor(max_workers=self.workers) as executor:
            futures = [
                executor.submit(process_transaction, i, trans)
                for i, trans in enumerate(transactions)
            ]
            
            for future in as_completed(futures):
                try:
                    index, categorized = future.result(timeout=30)
                    results[index] = categorized
                except Exception as e:
                    self.logger.error(f"Failed to process transaction: {e}")
        
        # Check for failed categorizations
        failed_count = sum(1 for r in results if r is None)
        if failed_count > 0:
            self.logger.warning(f"{failed_count} transactions could not be processed")
            # Fill in failed ones with ERROR category
            for i, result in enumerate(results):
                if result is None:
                    results[i] = CategorizedTransaction(
                        transaction=transactions[i],
                        category=TransactionCategory.ERROR
                    )
        
        final_results: list[CategorizedTransaction] = [r for r in results if r is not None]
        return final_results


if __name__ == "__main__":
    from storage.document_dao import InMemDAO
    from domain.statement_d import StatementMetaDataD, TransactionD
    from domain.document_d import DocumentD

    DATABASE_PATH = Path("bin/documents.json")
    OUTPUT_DIR = Path("bin")

    logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
    dao = InMemDAO()
    dao.load(DATABASE_PATH) 

    documents = dao.list_documents()

    # Process each document
    for doc in documents:
        if not doc.transactions:
            logging.info(f"Document {doc.document_id} has no transactions, skipping")
            continue
        
        logging.info(f"Categorizing transactions for document {doc.document_id}...")
        categorizer = TransactionCategorizationService()
        categorized = categorizer.categorize_transactions(doc.transactions)
        
        # Save categorized transactions to JSON
        output_path = OUTPUT_DIR / f"{doc.document_id}_categorized.json"
        with open(output_path, "w", encoding="utf-8") as f:
            json.dump([ct.to_dict() for ct in categorized], f, indent=2)
        
        logging.info(f"Saved categorized transactions to {output_path}")

    logging.info("All documents processed.")
    


